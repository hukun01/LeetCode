# 924. Minimize Malware Spread
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        '''
        Union find.
        Find all the connected components. From all components that have exactly
        one node overlapped with the initial infected list, we pick the overlapped
        node from the largest components.
        '''
        n = len(graph)
        uf = { i: i for i in range(n) }
        def find(i):
            if uf[i] != i:
                uf[i] = find(uf[i])
            return uf[i]
            
        for i in range(n):
            for j in range(n):
                if graph[i][j] == 1:
                    uf[find(i)] = find(j)
        
        components = collections.defaultdict(set)
        for i in range(n):
            components[find(i)].add(i)
        infected = set(initial)
        candidates = {}
        for c, nodes in components.items():
            intersected = nodes & infected
            if len(intersected) == 1:
                if len(nodes) in candidates:
                    candidates[len(nodes)] = min(candidates[len(nodes)], intersected.pop())
                else:
                    candidates[len(nodes)] = intersected.pop()
        return candidates[max(candidates)] if candidates else min(initial)